import type { Key } from 'ts-toolbelt/out/Any/Key'
import type { Dispatch, Middleware, ReducersMapObject, Store } from "redux"
import type { EnhancerOptions } from "@redux-devtools/extension"
import type { Saga, SagaMiddlewareOptions } from "redux-saga"
import type { CamelCase, PascalCase, Primitive, ScreamingSnakeCase } from 'type-fest'
import { List, O as _O } from 'ts-toolbelt'
import type { _ListOf } from 'ts-toolbelt/out/Object/ListOf'
import type { BuiltIn } from 'ts-toolbelt/out/Misc/BuiltIn'
import type { Tail } from 'ts-toolbelt/out/List/Tail'
import { Split } from 'ts-toolbelt/out/String/Split'

export const enum HandlerTypes {
  string = `string`,
  number = `number`,
  boolean = `boolean`,
  array = `array`,
  object = `object`,
  api = `api`,
  default = `default`,
}

export const enum RdxGeneratedPrefixes {
  set = `@@rdx/set`,
  get = `@@rdx/get`,
  reset_ = `@@rdx/reset_`,
  set_ = `@@rdx/set_`,
  RESET = `@@rdx/RESET_`,
  SET = `@@rdx/SET_`,
}

export type KeyMirroredObject<T> = Record<`${Extract<keyof T, string>}`, `${Extract<keyof T, string>}`>

export type Action<Payload = any, AdditionalKeys = never> = {
  type: string
  payload: Payload
} & (AdditionalKeys extends Record<string, any> ? AdditionalKeys: Record<string, never>)

export type ActionObject<State extends _O.Object, Prefix extends string> = Record<RdxActionName<Paths<State, 4, '_', 'camel'>, Prefix> | 'batchActions', ActionCreator<any, any>>

export type ActionCreator<Payload = any, AdditionalKeys = never> = (payload?: Payload, additionalKeys?: AdditionalKeys extends _O.Object ? _O.Object : never)
=> Action<Payload, AdditionalKeys>

export interface TypeDef {
  typeName: RdxSetTypeName<string, string> | RdxResetTypeName<string, string>
  actionName: RdxActionName<string, string>
  selectorName: RdxSelectorName<string, string>
  reducerKey: string
  handlerType: HandlerTypes
  initialState: Primitive | [] | Record<string, any>
  raw?: string
}

export type ConditionalFilter<T = string[]> = (
  item: string,
  index: number,
  collection: T
) => boolean

export type UserDefinedReducers = _O.Object

declare type PickDeep<
  O extends _O.Object,
  Path extends List.List<Key>,
  Depth = 4,
> = [Depth] extends [never] ? never :
  [] extends Path ? O :
    O extends BuiltIn ? O :
      O extends List.List ? _ListOf<{ [K in keyof _O.Pick<O, Path[0]>]: PickDeep<O[K], Tail<Path>, Depth>; }> : O extends _O.Object ? {
        [K in keyof _O.Pick<O, Path[0]>]: PickDeep<O[K], Tail<Path>, Depth>;
      } : O

export type PickFrom<O extends _O.Object, Path extends string = ReflectedStatePath<O>, BackupValue = null> =
Path extends `` ? O :
  Path extends ReflectedStatePath<O> ? PickDeep<O, Split<Path, '.'>, 4> :
    BackupValue extends never ? null : BackupValue

export type RdxSetTypeName<Name extends string, Prefix extends string> = `@@rdx/${ScreamingSnakeCase<`set${Prefix}_${Name}`>}`
export type RdxResetTypeName<Name extends string, Prefix extends string> = `@@rdx/${ScreamingSnakeCase<`reset${Prefix}_${Name}`>}`

export type RdxActionName<Name extends string, Prefix extends string> =
 | `set${PascalCase<`${Prefix}`>}${PascalCase<`${Name}`>}`
 | `set${PascalCase<`${Prefix}`>}${PascalCase<`${Name}`>}Request`
 | `set${PascalCase<`${Prefix}`>}${PascalCase<`${Name}`>}Failure`
 | `set${PascalCase<`${Prefix}`>}${PascalCase<`${Name}`>}Success`
 | `reset${PascalCase<`${Prefix}`>}${PascalCase<`${Name}`>}`

export type RdxSelectorName<Name extends string, Prefix extends string> = `get${PascalCase<Prefix>}${PascalCase<Name>}`

export type RdxTypesObject<Prefix extends string> = KeyMirroredObject<
RdxSetTypeName<string, Prefix> | RdxResetTypeName<string, Prefix>
> & KeyMirroredObject<RdxResetTypeName<'', Prefix>>

/**
 * type of paths generated by `getObjectPaths`
 */
export type ReflectedStatePath<State> = Paths<State, 4, '.'>

/**
 * paths used for generating actions and selectors
 */
export type StatePath<State> = Paths<State, 4, '_'>

export type SelectorPath<State> = RdxSelectorName<StatePath<State>, ''>

export type RdxSelector<State> = (v: State) => PickFrom<State>

export type SelectorsObject<State extends _O.Object> = Record<
SelectorPath<State>,
RdxSelector<State>
>

// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint
export type RdxReducer<S extends any = any, A = Action<S, any>> = (state: S, action: A) => S

export interface RdxDefinition<State> { reducerName: Paths<State, 0, '_'> | string; isApiReducer: boolean; definitions: TypeDef[] }

export interface RdxOutput<State extends _O.Object, Prefix extends string> {
  actions: ActionObject<State, Prefix>
  reducers: ReducersMapObject<State>
  selectors: SelectorsObject<State>
  types: RdxTypesObject<Prefix>
  state: State
}

export type RdxModule<State extends _O.Object, Prefix extends string> = RdxOutput<State, Prefix> & { [`@@rdx/prefix`]: Prefix }

export type Handler<State> =
  | ((initialState: State) => RdxReducer<State>)
  | ((key: string) => RdxReducer<State>)
  | RdxReducer<State>

export interface PregeneratedReducerKeys<State> {
  key: string
  handlers: Record<string, Handler<State>>
  handlerType: string
  initialState: State
}

export interface PregeneratedReducer<State> {
  reducerName: string
  keys: Array<PregeneratedReducerKeys<State>>
  reducerState: State
  reducerHandlers: Record<string, Handler<State>>
  isApiReducer: boolean
}

export interface ApiReducerKeys {
  request: string
  success: string
  failure: string
  reset: string
}

export interface ApiRequestState<DataType, ErrorType> {
  dataLoaded: boolean
  fetching: boolean
  error: ErrorType
  data: DataType
}

export interface ConfiguredSagasObject {
  latest?: DefaultSagasObject
  every?: DefaultSagasObject
}

type NotLatestOrEvery = Exclude<string, keyof ConfiguredSagasObject>

export type DefaultSagasObject = {
  [key in NotLatestOrEvery]: <ActionType = any>(action?: Action<ActionType>) => Generator;
}

export type SagasObject = ConfiguredSagasObject | DefaultSagasObject

export interface RdxSagasConfig {
  enabled: boolean
  options?: SagaMiddlewareOptions
}

export interface RdxModuleConfiguration<Prefix extends string> {
  /**
   *  The Prefix is the prefix that will be used for all the generated types, actions, reducers, selectors and sagas for this module, if they are going to be generated.
   *
   */
  prefix: Prefix
}

// TODO: add support for this option
// /**
//  * If you want to generate the types, actions, reducers, selectors and sagas for this module as a standalone, set this to true.
//  * If this module will be combined with others using `combineModules`, set this to false - things will be generated there.
//  * Defaults to true.
//  */
// standalone?: boolean

export type ModuleCombination<State extends _O.Object> = RdxOutput<State, ''>

export interface RdxRootConfiguration<State extends _O.Object> {
  modules: RdxOutput<State, ''>
  config?: {
    middleware?: Middleware[]
    devtools?: RdxDevToolsConfig
    sagas?: RdxSagasConfig
    wrapReducersWith?: (vs: any) => any
  }
}

export type ActionMapper<State extends _O.Object, Actions extends ActionObject<State, ''>> = (
  actions: Actions
)
=> (dispatch: Dispatch)
=> (...vs: Array<Paths<Actions, 0, '_', 'camel'>>)
=> Record<
Paths<Actions, 0, '_', 'camel'>,
ActionCreator<any, any>
>

export type SelectionMapper<State extends _O.Object> = (
  selectors: SelectorsObject<State>
) => (vs: Record<string, SelectorPath<State>>) => (state: State) => Record<string, ReturnType<RdxSelector<State>>>

export type ConfiguredStore<State extends _O.Object> = ModuleCombination<State> & {
  store: Store<State>
  runSagas: (sagas: Saga[]) => void
}

export interface RdxMappers<S extends _O.Object, Actions extends _O.Object = ActionObject<S, ''>> {
  mapActions: ReturnType<ActionMapper<S, Actions>>
  mapState: ReturnType<SelectionMapper<S>>
}

export interface IntegratedRdxMappers<S extends _O.Object, Actions extends _O.Object> {
  mapActions: ReturnType<ReturnType<ActionMapper<S, Actions>>>
  mapState: ReturnType<SelectionMapper<S>>
}

export interface RdxDevToolsConfig {
  enabled: boolean
  options?: EnhancerOptions
}

/**
 * types to get a list of all possible paths from an object
 * credit to: Michael Ziluck
 * https://stackoverflow.com/questions/58434389/typescript-deep-keyof-of-a-nested-object
 */

type Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...Array<0>]

export type RdxPrefixed<Str extends string> = `@@rdx/${Str}`

export type Join<Key, Path, Delimiter extends string = '_', Case extends string = ''> =
  Key extends string | number ?
    Path extends string | number ?
      Case extends `camel` ? CamelCase<`${Key}${Delimiter}${Path}`> : `${Key}${Delimiter}${Path}`
      : never
    : never

export type Paths<Tree, Depth extends number = 5, Delimiter extends string = '_', Case extends string = ''> = [Depth] extends [never] ? never
  : Tree extends Record<string, any> ?
    { [Key in keyof Tree]-?: Key extends string | number ?
    `${Key}` | Join<Key, Paths<Tree[Key], Prev[Depth], Delimiter, Case>, Delimiter>
      : never
    }[keyof Tree] : ""

export type Leaves<Tree, Depth extends number = 5, Delimiter extends string = '_'> = [Depth] extends [never] ? never : Tree extends Record<string, any> ?
  { [K in keyof Tree]-?: Join<K, Leaves<Tree[K], Prev[Depth], Delimiter>, Delimiter> }[keyof Tree] : ""

export type DeepPartial<T, Depth = 5> = [Depth] extends [never] ? never :
  {
    [P in keyof T]?: T[P] extends Array<infer U>
      ? Array<DeepPartial<U>>
      : T[P] extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : DeepPartial<T[P]>;
  }

export type DeepValueOf<State extends _O.Object, Path extends ReflectedStatePath<State> = ReflectedStatePath<State>, BackupValue = undefined> =
  PickFrom<State, Path> extends undefined | never
    ? BackupValue extends undefined | never ? null : BackupValue
    : PickFrom<State, Path>
